rules_version = '2';

/**
 * Firestore Security Rules - Production-Ready
 * 
 * Design Principles:
 * - Fail Closed: Deny by default, allow explicitly
 * - Explicit Validation: All writes validated server-side
 * - Audit Trail: Immutable logs, no deletions
 * - Role-Based Access: Admin > Instructor > Staff hierarchy
 * 
 * Last Updated: Phase 2 - Verification Panel Fixes
 * 
 * Changes from Phase 1.5:
 * - progress/create: Removed hasRequiredFields enforcement (moved to service layer).
 *   Schema validation belongs at the TypeScript boundary, not the auth layer.
 *   Rules enforce WHO can write; services enforce WHAT shape is written.
 * - progress/create: Admin bypass now explicit (isAdmin() first, matching enrollment pattern).
 * - audit_logs/create: Relaxed hasRequiredFields to only require actorId (the security-critical
 *   field). Other fields enforced by auditService contract. Prevents silent denials from
 *   optional fields being missing on legitimate writes.
 */

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
        request.auth.token.role == 'admin';
    }
    
    function isInstructor() {
      return isAuthenticated() && 
        request.auth.token.role == 'instructor';
    }
    
    function canAuthorContent() {
      return isAdmin() || isInstructor();
    }
    
    function hasAnyRole(roles) {
      return isAuthenticated() && 
        request.auth.token.role in roles;
    }
    
    // ============================================
    // VALIDATION HELPERS
    // ============================================
    
    function isValidTimestamp(field) {
      return request.resource.data[field] is timestamp;
    }
    
    function hasRequiredFields(fields) {
      return request.resource.data.keys().hasAll(fields);
    }
    
    function isValidGradeScore(score) {
      return score is number && score >= 0 && score <= 100;
    }
    
    function isValidProgress(progress) {
      return progress is number && progress >= 0 && progress <= 100;
    }
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) || isAdmin();
      allow update: if isAdmin() || (
        isOwner(userId) && 
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'uid'])
      );
      allow delete: if isAdmin();
    }
    
    // ============================================
    // COURSES
    // ============================================
    
    match /courses/{courseId} {
      allow read: if isAuthenticated() && (
        resource.data.status == 'published' || canAuthorContent()
      );
      allow create: if canAuthorContent() && 
        hasRequiredFields(['title', 'description', 'status', 'createdAt']);
      allow update: if canAuthorContent();
      allow delete: if isAdmin();
      
      match /modules/{moduleId} {
        allow read: if isAuthenticated() && (
          get(/databases/$(database)/documents/courses/$(courseId)).data.status == 'published' 
          || canAuthorContent()
        );
        allow create: if canAuthorContent() && 
          hasRequiredFields(['title', 'courseId', 'weight']);
        allow update: if canAuthorContent();
        allow delete: if isAdmin();
        
        match /blocks/{blockId} {
          allow read: if isAuthenticated();
          allow create, update: if canAuthorContent() && 
            hasRequiredFields(['type', 'moduleId', 'order']);
          allow delete: if canAuthorContent();
        }
      }
    }
    
    // ============================================
    // ENROLLMENTS
    // ============================================
    
    match /enrollments/{enrollmentId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || 
        hasAnyRole(['admin', 'instructor'])
      );
      allow create: if (
        isAdmin() || 
        (isAuthenticated() && request.resource.data.userId == request.auth.uid)
      ) && 
        hasRequiredFields(['userId', 'courseId', 'progress', 'status', 'enrolledAt']) &&
        isValidProgress(request.resource.data.progress);
      allow update: if (
        isAuthenticated() && (
          resource.data.userId == request.auth.uid || isAdmin()
        )
      ) && (
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['progress']) ||
        isValidProgress(request.resource.data.progress)
      );
      allow delete: if isAdmin();
    }
    
    // ============================================
    // PROGRESS TRACKING
    // ============================================
    
    match /progress/{progressId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || 
        hasAnyRole(['admin', 'instructor'])
      );

      // CHANGED: Removed hasRequiredFields() and field-level validation.
      // Authorization rule: WHO can write (admin, or the document's own userId).
      // Schema validation: enforced by progressService TypeScript contracts.
      // Rationale: Rules cannot safely validate nested map fields (completedBlocks)
      // or conditional optional fields without risking false denials on legitimate writes.
      allow create: if isAdmin() ||
        (isAuthenticated() && request.resource.data.userId == request.auth.uid);

      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || isAdmin()
      );

      allow delete: if isAdmin();
    }
    
    // ============================================
    // GRADES (Sensitive - Legal Defensibility)
    // ============================================
    
    match /grades/{gradeId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        hasAnyRole(['admin', 'instructor'])
      );
      // Schema validation retained here: score bounds are a compliance requirement
      // that cannot be trusted to client-side code alone.
      allow create: if hasAnyRole(['admin', 'instructor']) &&
        hasRequiredFields(['userId', 'moduleId', 'score', 'passingScore', 'gradedBy']) &&
        isValidGradeScore(request.resource.data.score) &&
        isValidGradeScore(request.resource.data.passingScore) &&
        request.resource.data.gradedBy == request.auth.uid;
      allow update: if hasAnyRole(['admin', 'instructor']) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['userId', 'moduleId']) &&
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['score']) ||
         isValidGradeScore(request.resource.data.score));
      allow delete: if false;
    }
    
    // ============================================
    // COURSE GRADES (Weighted Calculations)
    // ============================================
    
    match /course_grades/{gradeId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        hasAnyRole(['admin', 'instructor'])
      );
      allow create, update: if hasAnyRole(['admin', 'instructor']) &&
        hasRequiredFields(['userId', 'courseId', 'overallScore', 'overallPassed']) &&
        isValidGradeScore(request.resource.data.overallScore);
      allow delete: if false;
    }
    
    // ============================================
    // AUDIT LOGS (Immutable)
    // ============================================
    
    match /audit_logs/{logId} {
      allow read: if isAdmin() || isInstructor();
      
      // CHANGED: Only require actorId for security enforcement.
      // The actorId == auth.uid check is the critical security invariant:
      // it prevents one user from forging audit logs as another.
      // Other field presence (actorName, actionType, details) is enforced
      // by the auditService contract, not the rules layer.
      // Rationale: hasRequiredFields for optional/contextual fields caused
      // silent write failures when callers omitted non-security-critical fields.
      allow create: if isAuthenticated() && 
        request.resource.data.actorId == request.auth.uid;
      
      // CRITICAL: No updates or deletes â€” ever
      allow update, delete: if false;
    }
    
    // ============================================
    // REMEDIATION REQUESTS (Supervisor Approval)
    // ============================================
    
    match /remediation_requests/{requestId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.supervisorId == request.auth.uid ||
        isAdmin()
      );
      allow create: if (
        isAuthenticated() && request.resource.data.userId == request.auth.uid
      ) || isAdmin();
      allow update: if isAuthenticated() && (
        resource.data.supervisorId == request.auth.uid || isAdmin()
      ) && (
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['status', 'resolvedAt', 'resolvedBy', 'resolutionNotes'])
      );
      allow delete: if false;
    }
    
    // ============================================
    // COMPETENCIES (User Skill Tracking)
    // ============================================
    
    match /competencies/{competencyId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        hasAnyRole(['admin', 'instructor'])
      );
      allow create, update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // ============================================
    // CATCH-ALL: Deny everything else
    // ============================================
    
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
